---
layout: post
active: articles
caption: Collection of Backbone.js tips, patterns, and best practices, from PUTs requiring an id to handling parameter mapping in routers.
title: Backbone.js Tips, Patterns, and Best Practices
comments: true
---
<strong>***An updated version of this article is availble <a alt="SmashingMagazine.com Backbone.js Tips and Patterns" href="http://coding.smashingmagazine.com/2013/08/09/backbone-js-tips-patterns/">here</a>***.</strong>
<p>
If you're not familiar with Backbone.js then you should skip this article and head over to <a href="http://www.backbonejs.org" alt="Backbone.js">http://backbonejs.org</a>.
</p>
<p>
I've been developing Backbone.js applications for about a year and half and in doing so there are a quite a few patterns that I've found myself repeating and a few best practices that I've picked up. There were also a few "gotchas" in the beginning that took some time to figure out. In case you don't want to read through all of these, just skip to the <a href="#summary">summary</a>.
</p>
<ul>
    <li><a href="#perform-deep-copy">Perform a Deep Copy</a></li>
    <li><a href="#facades">Create Facades To Objects</a></li>
    <li><a href="#rerender">Re-render > DOM Manipulation</a></li>
    <li><a href="#router-parameter-mapping">Parameter Mapping in Routers</a></li>
    <li><a href="#puts-require-id">PUTs Require an id Attribute</a></li>
    <li><a href="#fetch-doesnt-clear">model.fetch() Doesn't Clear Your Model</a></li>
    <li><a href="#validation">Model Validation Can Return Anything</a></li>
    <li><a href="#fetch-from-views">Fetch Models and Collections from Within Views</a></li>
    <li><a href="#http-status-error">HTTP Status Code 200 Trigger Error</a></li>
    <li><a href="#single-page-app-titles">Update Single Page App Titles</a></li>
    <li><a href="#cache-single-page-app-components">Cache Single Page App Components for Reuse</a></li>
    <li><a href="#create-generic-error">Create a Generic Error Display</a></li>
    <li><a href="#jsdoc-everything">JSDocs Functions and Backbone.js Classes</a></li>
    <li><a href="#test-driven-development">Practice Test Driven Development</a></li>
</ul>

<h3><a name="perform-deep-copy">Perform a Deep Copy</a></h3>
<p>
This is a problem that I ran into pretty quickly and it comes from the nature of JavaScript's pass-by-reference and pass-value behavior. This problem is best described with an example. Let's say that you have a Person model that looks something like this:
</p>
{% highlight javascript %}
var Person = Backbone.Model.extend({
   defaults: {
        'name': 'Jon Doe',
        'address': {
            'street': '1st Street'
            'city': 'Austin',
            'state': 'TX'
            'zipCode': 78701
        }
   }
});

{% endhighlight %}
<p>
And you create a new person.
</p>
{% highlight javascript %}
var person = new Person({
    'name': 'Phillip W'
});
{% endhighlight %}
<p>
Now let's manipulate some of the attributes of the person object that we created.
</p>
{% highlight javascript %}
person.set('name', 'Phillip W.');
{% endhighlight %}
<p>
The above code successfully manipulates the name attribute of the person object. Now let's try to manipulate the address of the person object. Before we do so, let's add some validation for the address. 
</p>
{% highlight javascript %}
var Person = Backbone.Model.extend({
    validate: function(attributes) {

        if(isNaN(attributes.address.zipCode)) {
            return "Address Zip Code must be a number!";
        }
    },

    defaults: {
        'name': 'Jon Doe',
        'address': {
            'street': '1st Street'
            'city': 'Austin',
            'state': 'TX'
            'zipCode': 78701
        }
    } 
});
{% endhighlight %}
<p>
Now let's attempt to manipulate the address with an incorrect zip code.
</p>
{% highlight javascript %}
var address = person.get('address');
address.zipCode = 'Hello World';
// Raises an error since the zipCode is invalid
person.set('address', address);
console.log(person.get('address'));
/* Prints an object with these properties.
{
    'street': '1st Street'
    'city': 'Austin',
    'state': 'TX'
    'zipCode': 'Hello World'
}
*/
{% endhighlight %}

<p>
How could this be! Our validation raised an error! Why are the attributes still changed?  This is because Backbone.js simply returns Objects and does not perform a deep copy. Since JavaScript treats Objects as pass-by-reference any manipulation to the object will directly manipulate the actual object in the model. This can quickly lead you down a very dark rabbit hole.
</p>
<p>
This isn't an alarming issue for anyone that has been writing JavaScript, but it is an issue that catches a lot of those new to Backbone.js. This issue has been heavily discussed in the <a href="https://github.com/documentcloud/backbone/issues/2315" alt="github issue">github issues</a> section of Backbone.js. As Jeremy Ashkenas points out, it is a very difficult problem to solve. It can also become an expensive operation for very large, deep objects.</p>
<p>
Luckily, jQuery provides an implementation of deep copying, <a href="http://api.jquery.com/jQuery.extend/" alt="jQuery extend">$.extend</a>. I perform a deep copy of any Object that I .get() from a model using the following syntax. Remember to pass true, so that it performs a deep copy.
</p>
{% highlight javascript %}
var address = $.extend(true, {}, person.address);
{% endhighlight %}
<p>
We now have an exact copy of the address object and we can modify it to our hearts extent without worry about modifying the actual model.
</p>

<h3><a name="facades">Create Facades To Objects</a></h3>
<p>
In the real world requirements change often, and therefore, so does the JSON returned by the endpoints that your models and collections hit. This can become a really big pain if your view is tigthly coupled to the underlying data model. Therefore, I create getters and setters for all objects.
</p>
<p>
This pattern is advantageous because if any of the underlying data structures change, the view layers shouldn't have to update that much, you will have one point of access to the data so it's less likely that you will forget to do a deep copy, code is more maintainable, and code much easier to debug. The downsides to this pattern is that it can cause a bit of bloat in your models or collections and it adds a small performance hit each time you access the data.
</p>
<p>
Let's look at an example to help illustrate this pattern. Let's imagine that we have a hotel model that contains rooms and the currently available rooms. Let's also imagine that we want to be able to retrieve rooms by bed.
</p>

{% highlight javascript %}
var Hotel = Backbone.Model.extend({
    initialize: function() {
        _.bindAll(this, 'getRoomsByBed', 'getRooms');
    },

    defaults: {
        "availableRooms": ["a"],
        "rooms": {
            "a": {
                "size": 1200,
                "bed": "queen"
            },
            "b": {
                "size": 900,
                "bed": "twin"
            },
            "c": {
                "size": 1100,
                "bed": "twin"
            }
        },

        getRooms: function() {
            $.extend(true, {}, this.get("rooms"));
        },

        getRoomsByBed: function(bed) {
            return _.where(this.getRooms(), function() {
                { "bed": bed }
            });
        }
    }
});
{% endhighlight %}

<p>
Now let's imagine that you're a day before releasing your code and you find out that the endpoint developers forgot to tell you that the data structure of rooms has changed. Your code now looks like this:
</p>

{% highlight javascript %}
var Hotel = Backbone.Model.extend({
    initialize: function() {
        _.bindAll(this, 'getRoomsByBed', 'getRooms');
    },

    defaults: {
        "availableRooms": ["a"],
        "rooms": [
            {
                "name": "a",
                "size": 1200,
                "bed": "queen"
            },
            {
                "name": "b",
                "size": 900,
                "bed": "twin"
            },
            {
                "name": "c",
                "size": 1100,
                "bed": "twin"
            }
        ],

        getRooms: function() {
            var rooms = $.extend(true, {}, this.get("rooms")),
             newRooms = {};

            _.each(rooms, function(room) {
                newRooms[room.name] = {
                    "size": room.size,
                    "bed": room.bed
                }
            });
        },

        getRoomsByBed: function(bed) {
            return _.where(this.getRooms(), function() {
                { "bed": bed }
            });
        }
    }
});
{% endhighlight %}

<p>
As you can tell we were able to update one function and our entire app still behaves as expected. If we didn't have a getter here, we could potentially have to update each point of access to rooms. Ideally, you would want to update all of your functions to work with the new data structure, but if you're time pressed and have to release, this pattern can save you.
</p>

<p>
As an aside, if your into design patterns like I am, this approach is known as a <a href="http://addyosmani.com/resources/essentialjsdesignpatterns/book/#facadepatternjavascript" alt="Facade Design Pattern">facade design pattern</a>. A good rule of thumb is to use getters and setters on anything that is an object.
</p>

<h3><a name="rerender">Re-render > DOM Manipulation</a></h3>
<p>
This is a pattern that I strongly follow and suggest you do as well. I move as much data into the model as I can and try to keep my views as minimal as possible. To explain this pattern let's look at an example.
</p>
<p>
Lets say that you have a ul list like this.
</p>
{% highlight html %}
<ul id="items">
    <li>
        <a href="#" data-id="1">One</a>
    </li>
    <li>
        <a href="#" data-id="2">Two</a>
    </li>
    <li>
        <a href="#" data-id="3">Three</a>
    </li>
</ul>
{% endhighlight %}

<p>
And when the user clicks on one of the items it becomes selected and is visualized to the user as the chosen item by adding a class 'selected'. One approach to this would be the following.
</p>

{% highlight javascript %}
var Model = Backbone.Model.extend({
    defaults: {
        items: [
            {
                "name": "One",
                "id": 1           
            },
            {
                "name": "Two",
                "id": 2           
            },
            {
                "name": "Three",
                "id": 3           
            }
        ]
    }
});

var View = Backbone.View.extend({
    initialize: function(options) {
        _.bindAll(this, 'setSelectedItem');
    },

    template: _.template($('#list-template').html()),

    events: {
        "#items li a": "setSelectedItem"
    },

    render: function() {
        $(this.el).html(this.template(this.model.toJSON()));
    },

    setSelectedItem: function(event) {
        var selectedItem = $(event.currentTarget);
        // Set all of the items to not have the selected class
        $('#items li a').removeClass('selected');
        selectedItem.addClass('selected');
        return false;
    }
});
{% endhighlight %}

{% highlight javascript %}
<script type="template" id="list-template">
    <ul id="items">
        <% for(i = items.length - 1; i >= 0; i--) { %>
            <li>
                <a href="#" data-id="<%= item[i].id %>"><%= item[i].name %></a>
            </li>
        <% } %>
    </ul>
</script>
{% endhighlight %}

<p>
Now this approach is OK, but if we want to figure out what item is selected we'll have to traverse the list in the DOM and if the list grows really large this can become quite an expensive task. A cleaner approach and more Backbony(This a word?) approach would be to move this logic into the model and then have the UI update based on changes to the model.
</p>

{% highlight javascript %}
var Model = Backbone.Model.extend({
    initialize: function() {
        _.bindAll(this, 'setSelectedItem');
    },

    defaults: {
        selectedId: undefined,
        items: [
            {
                "name": "One",
                "id": 1
            },
            {
                "name": "Two",
                "id": 2
            },
            {
                "name": "Three",
                "id": 3
            }
        ]
    }
});

var View = Backbone.View.extend({
    initialize: function(options) {
        _.bindAll(this, 'setSelectedItem');
        // Rerender when the model changes
        this.model.on('change', this.render, this);
    },

    template: _.template($('#list-template').html()),

    events: {
        "#items li a": "setSelectedItem"
    },

    render: function() {
        $(this.el).html(this.template(this.model.toJSON()));
    },

    setSelectedItem: function(event) {
        this.model.set('selectedId', $(event.currentTarget).data('id'));
        return false;
    }
});
{% endhighlight %}

{% highlight html %}
<script type="template" id="list-template">
    <ul id="items">
        <% for(i = items.length - 1; i >= 0; i--) { %>
            <li>
                <a href="#" data-id="<%= item[i].id %>" <%= (item[i].id === selectedId)? 'class="selected"': '' %> ><%= item[i].name %></a>
            </li>
        <% } %>
    </ul>
</script>
{% endhighlight %}

<p>
Now we have the UI simply updating the model, which triggers a rerender, and we don't have to traverse the DOM at all to determine what elements are selected. A good rule of thumb is to push as much logic into the model as possible.
</p>

<h3><a name="router-parameter-mapping">Parameter Mapping in Routers</a></h3>
<p>
The best way to demonstrate how this pattern came about is through an example. Let's say that you have some sort of search page and that the search page allows users to add two different filter types foo and bar, where foo and bar can each have a multitude of options. Therefore, your URL structure would start off looking something like this:
</p>

{% highlight javascript %}
'search/:foo'
'search/:bar'
'search/:foo/:bar'
{% endhighlight %}

<p>
Now all of these routes use the exact same view and model so you would ideally like them to all use the same funciton, search(). However, if you examine Backbone.js there isn't any sort of parameter mapping, the parameters are just plopped into the function from left to right. So in order for them to all use the same function you end up creating different functions to correctly map the parameters to search().
</p>

{% highlight javascript %}
routes: {
    'search/:foo': 'searchFoo',
    'search/:bar': 'searchBar',
    'search/:foo/:bar': 'search'
},

search: function(foo, bar) {    
},

// I know this function will actually still map correctly, but for explanatory purposes it's left in. :)
searchFoo: function(foo) {
    this.search(foo, undefined);
},

searchBar: function(bar) {
    this.search(undefined, bar);
},
{% endhighlight %}
<p>
As you can imagine this pattern can quickly bloat your routers. When I first ran into this problem I attempted to do some magic parsing of the actual function definitions with regexs to 'magically' map the parameters, which would have worked but only if you followed specific constraints so I scrapped the idea (I might still throw this into a Backbone plugin sometime). Anyways, I opened an <a href="https://github.com/documentcloud/backbone/issues/1833" alt="Backbone.js router parameter mapping issue">issue on github</a> and <a href="http://ashkenas.com/" alt="Jeremy Ashkenas website">Jeremy Ashkenas</a> suggested mapping all of the paremeters in the search function.
</p>
<p>
The above code now transforms into something much more maintainable.
</p>
{% highlight javascript %}
routes: {
    'base/:foo': 'search',
    'base/:bar': 'search',
    'base/:foo/:bar': 'search'
},

search: function() {
    var foo, bar, i;

    for(i = arguments.length - 1; i >= 0; i--) {

        if(arguments[i] === 'something to determine foo') {
            foo = arguments[i];
            continue;
        }
        else if(arguments[i] === 'something to determine bar') {
            bar = arguments[i];
            continue;
        }
    }
},
{% endhighlight %}
<p>
This pattern can drastically reduce router bloat. However, you should be aware that this pattern will not work for parameters that are not indistinguishable. For example, if you had two parameters that were both ids and followed the pattern XXXX-XXXX, you would not be able to identify which id corresponded to which parameter.
</p>

<h3><a name="puts-require-id">PUTs Require an id Attribute</a></h3>
<p>This tip catches a lot of those new to Backbone.js. All PUTs require that models have an id attribute set. This is great, but in the real world JSON data that you recieve from endpoints will likely not have perfectly named ids. Therefore, if you need to update a model by sending a PUT request be sure that there is an id on the model before saving it. A quick way to get around having to do this is to have your parse function of your collection or model check for the presence of an id attribute and add an id attribute if there isn't one present.</p>
<p>
To illustrate this idea let's imagine that you have a collection of cars that have ids called carId instead of id:
</p>

{% highlight javascript %}
parse: function(response) {

    _.each(response.cars, function(car, i) {
        // If for some reason the car doesn't have a carId, just give it the id of i
        response.cars[i].id = (response.cars[i].carId ? response.cars[i].carId: i);
    });

    return response;
},
{% endhighlight %}

<h3><a name="fetch-doesnt-clear">model.fetch() Doesn't Clear Your Model</a></h3>
<p>
    Model.fetch() does not clear out your model, but extends the attributes of the model. Therefore, if your model has attributes x, y, and z and your fetch returns y and z, x will still be in the model and only y and z will be updated.
</p>

<h3><a name="validation">Model Validation Can Return Anything</a></h3>
<p>
    You can pass anything back in the validation step of models. You might be asking yourself, "Why would this be useful?". Let's say that you have an extremely complex form field that you need to highlight the exact form areas that have errors on them. Instead of having a validation like this:
</p>
{% highlight javascript %}
// Inside your model
validate: function(attrs) {
    if(attrs.a < 0) {
        $('.a').addClass('error');
        return "Form field a is messed up!";
    }
    if(attrs.b < 0) {
        $('.b').addClass('error');
        return "Form field b is messed up!";
    }
}
// Inside your view
this.model.on('error', function(model, error) {
   alert(error); 
});
{% endhighlight %}

<p>
    You could have something like this:
</p>
{% highlight javascript %}
// Inside your model
validate: function(attrs) {
    var errors = [];

    if(attrs.a < 0) {
        errors.push({
            'message': 'Form field a is messed up!',
            'class': 'a'
        });
    }
    if(attrs.b < 0) {
        errors.push({
            'message': 'Form field b is messed up!',
            'class': 'b'
        });
    }

    if(errors.length) {
        return errors;
    }
}
// Inside your view
this.model.on('error', function(model, errors) {
    _.each(errors, function(error, i) {
        $(error.class).addClass('error');
        alert(error.message);
    });
});
{% endhighlight %}

<p>
    So keep in mind that you can return more then a simple error string in your validation.
</p>

<h3><a name="fetch-from-views">Fetch Models and Collections from Within Views</a></h3>
<p>
A good pattern is to always call .fetch() of models from within the view that they are tied to. This approach keeps all error message displaying in the view layer, where it belongs.
</P>

<h3><a name="http-status-error">HTTP Status Code 200 Trigger Error</a></h3>
<p>
If the endpoint that your model or collection is hitting returns invalid JSON your model or collection will trigger an 'error' event, even if the endpoint returned a 200 status code. I've run into this issue mostly when developing locally against mock data, so a good rule of thumb is to throw any mock JSON files your developing against through a JSON validator, such as <a href="http://jsonformatter.curiousconcept.com/" alt="JSON formatter">http://jsonformatter.curiousconcept.com/</a>, or just get a plugin for the IDE of your choice that will catch any ill formatted JSON.
</p>

<h3><a name="create-generic-error">Create a Generic Error Display</a></h3>
<p>
This can save you a good amount of time and is fairly straight forward. In any Backbone.js app you create you, you should create a generic view and model that handles alerts for you. That way you can do something like this in your initialization of your views:
</p>

{% highlight javascript %}
    this.model.on('error', function(model, error) {
        app.alert('TYPE-OF-ERROR', error);
    });
{% endhighlight %}
<p>
    It's also a good idea to have a general alert div in the layout of your application so that in case you forget to put in an alert div in your views markup, the alert view can fall back to the layouts alert div.
</p>

<h3><a name="single-page-app-titles">Update Single Page App Titles</a></h3>
<p>
This is more of a usability concern then anything. If you're developing a single page application, remember to update the title of each page! If I get some time I'd like to create a plugin to bake this functionality into the router of Backbone.js. Maybe something like:
</p>
{% highlight javascript %}
routes: {
    'base/:foo/:bar': 'fooBar'
},

titles: {
    'base/:foo/:bar': 'Foo and Bar'
}
{% endhighlight %}

<h3><a name="cache-single-page-app-components">Cache Single Page App Components for Reuse</a></h3>
<p>
    Since we are on the topic of single page applications, another tip is to cache components that are reused! This is fairly straight forward and a simple example is as follows:
</p>

{% highlight javascript %}
// Inside a router
initialize: function() {

    this.cached = {
        view: undefined,
        model: undefined
    }
},

index: function(parameter) {
    this.cached.model = this.cached.model || new Model({
        parameter: parameter
    });
    this.cached.view = this.cached.view || new View({
        model: this.cached.model
    });
}
{% endhighlight %}

<p>
    Those that have been developing Backbone.js apps will likely say something along the lines of "what if I want to refetch data?". What you don't want to do is this:
</p>

{% highlight javascript %}
// Inside a router
initialize: function() {

    this.cached = {
        view: undefined,
        model: undefined
    }
},

index: function(parameter) {
    this.cached.model = this.cached.model || new Model({
        parameter: parameter
    });
    this.cached.view = this.cached.view || new View({
        model: this.cached.model
    });
    this.cached.model.fetch();
}
{% endhighlight %}
 <p>
    This approach is OK, but what if the user hasn't changed state(parameter), since they were last on this page? A better solution would be:
 </p>

{% highlight javascript %}
// Inside a router
initialize: function() {

    this.cached = {
        view: undefined,
        model: undefined
    }
},

index: function(parameter) {
    this.cached.model = this.cached.model || new Model({
        parameter:parameter
    });
    this.cached.view = this.cached.view || new View({
        model: this.cached.model
    });
}

// Inside of the view
initialize: function() {
    var that = this;
    this.model.on("change:parameter", function() {
        that.model.fetch();
    });
}
{% endhighlight %}

<p>This way your only fetching data when the state of the application changes.</p>

<h3><a name="jsdoc-everything">JSDocs Functions and Backbone.js Classes</a></h3>
<p>
I'm a huge fan of documentation and <a href="https://code.google.com/p/jsdoc-toolkit/" alt="JSDocs">JSDocs</a>. I JSDoc all Backbone classes, which I got the syntax from a stackoverflow answer a long time ago, and functions in the following format.
</p>
{% highlight javascript %}
var Thing = Backbone.View.extend(/** @lends Thing.prototype */{
    /**
     * @class Thing
     *
     * @author Phillip Whisenhunt
     * @augments Backbone.View
     * @contructs Thing object
     */
    initialize() {},

    /**
     * Gets data by id from the thing. If the thing doesn't have data based on the id, it returns an empty string.
     *
     * @param {String} id The id of get data for.
     * @return {String} The data.
     */
    getDataById: function(id) {}
});
{% endhighlight %}

<p>
If you document your Backbone classes in the above format you can generate beaufiful documentation that will contain all of your classes and functions with parameters, return types, and descriptions. 
</p>

<h3><a name="test-driven-development">Practice Test Driven Development</a></h3>
<p>
    I thought I would share how I go about my day to day workflow. A lot of those new to Backbone.js start with developing the view, but I start with the data. Before I begin any Backbone.js component I work out a clear JSON contract that I plan on communicating to the backend with. I then talk with product and design to discuss the functionality of the component and usually this will influence the data model.
</p>
<p>
    Once I get as close to what the JSON contract should be I throw the an example of the contract data into the models defaults and I start writing failing <a href="http://pivotal.github.com/jasmine/" alt="Jasmine">Jasmine</a> unit tests. I write Jasmine unit tests around functions that I think that the view could potentially need to update the model and as the previous patterns suggests, I write getters and setters for all Objects in the model. Once the unit tests are written and failing I then go and flush out the model.
</p>
<p>
    By this point all of the Jasmine tests are passing and I have confidence that my model functions all work as expected. Since I followed TDD, my view layer is now super easy to write and is also extremely thin. So in summary my typical workflow is:
    <ol>
        <li>Figure out JSON contract</li>
        <li>Talk with product and design about UI and update model accordingly</li>
        <li>Write failing Jasmine unit tests</li>
        <li>Write model so Jasmine unit tests pass</li>
        <li>Tie in view</li>
    </ol>
    If you begin practicing TDD you are definitely going to be slowed down at first, but once you get your head wrapped around it, your productivity and quality of code will definitely increase.
</p>
<h3><a name="summary">Summary</a></h3>
<ul>
    <li><strong>Perform a Deep Copy</strong>
        <p>Deep copy Objects from your models.</p>
    </li>
    <li><strong>Create Facades To Objects</strong>
        <p>To help limit the possibly of not deep copying an object, create a single point of access for all Objects in your models. This also helps you in the case that your endpoint JSON changes and you have one day to migrate to the new JSON schema. Instead of having to update all of your code, you could update a single function to massage the data into the previous format.</p>
    </li>
    <li><strong>Re-render > DOM Manipulation</strong>
        <p>Throw extra data into the model that allows you to determine state of the UI. If the UI changes, update the state and re-render. This allows you quickly know the state of the UI without having to traverse the DOM.</p>
    </li>
    <li><strong>Parameter Mapping in Routers</strong>
        <p>Instead of having different routes call different functions that all call to a single router function, have all of the different routes call the same router function and handle parameter mapping in a single function.</p>
    </li>
    <li><strong>PUTs Require an id Attribute</strong>
        <p>To send a put with model.save() the model must have an id attribute. If your JSON endpoint doesn't have ids, add them during the parse.</p>
    </li>
    <li><strong>model.fetch() Doesn't Clear Your Model</strong>
        <p>model.fetch() doesn't clear your model, it only extends and overwrites the model attributes that currently exist.</p>
    </li>
    <li><strong>Model Validation Can Return Anything</strong>
        <p>The validate function of a model can return anything.</p>
    </li>
    <li><strong>Fetch Models and Collections from Within Views</strong>
        <p>Keep view logic in the view by calling .fetch for collections and models from within their views.</p>
    </li>
    <li><strong>HTTP Status Code 200 Trigger Error</strong>
        <p>If your models or collections receive invalid JSON they will trigger an error, even if the status code is 200. This happens alot when developing against mock JSON. Therefore, when developing locally, throw all of your example JSON data through a JSON formatter or use an IDE JSON linter.</p>
    </li>
    <li><strong>Update Single Page App Titles</strong>
        <p>Don't forget to update the page titles of all pages in a single page app.</p>
    </li>
    <li><strong>Cache Single Page App Components for Reuse</strong>
        <p>Cache components in a single page app and have the models update when state changes.</p>
    </li>
    <li><strong>Create a Generic Error Display</strong>
        <p>Create a generic error handling view and model for any Backbone.js app. Create a specific error div for each page that the view can bind to and a general error div on your page layout that the Backbone view can fall back to in case you forget to create a specific one.</p>
    </li>
    <li><strong>JSDocs Functions and Backbone.js Classes</strong>
        <p>JSDoc Backbone.js classes and functions.</p>
    </li>
    <li><strong>Practice Test Driven Development</strong>
        <p>Practive Test Driven Development with your models and collections. It will be painful at first, but once you get the hang of it, it will drastically increase your productivity and you'll have more integrity that your code is performing as it should.</p>
    </li>
</ul>

<p>
I hope that these tips, patterns, and best practices helped! If you have suggestions for other patterns, find a typo, or think that one of these patterns isn't the best approach please tweet me or send a pull request. Thanks to <a href="http://www.mountaindrawn.com/" alt="Patrick Lewis Website">Patrick Lewis</a> and <a href="http://addyosmani.com/blog/" al="Addy Osmani Website">Addy Osmani</a> for giving this article a quick proofread.
</p>